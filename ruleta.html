<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ruleta de Emociones Multicapa</title>
<style>
body {
  margin: 0;
  font-family: Arial, sans-serif;
  background-color: white;
  color: black;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  min-height: 100vh;
  position: relative;
}

/* === Contenedor adaptable === */
#contenedor-ruleta {
  position: relative;
  width: 90vw;
  max-width: 550px;
  aspect-ratio: 1/1.18;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: visible;
}

/* === Soportes (ajustados para alineación perfecta del triángulo) === */
#soporte-atras, #soporte-adelante {
  position: absolute;
  top: -2%;
  left: -2%;
  width: 104%;
  height: 104%;
  object-fit: contain;
  pointer-events: none;
  z-index: 0;
}

#soporte-adelante {
  z-index: 3;
}

/* === Canvas perfectamente centrado === */
#ruleta {
  border-radius: 50%;
  cursor: grab;
  width: 82%;
  height: auto;
  position: relative;
  top: 5%; /* bajado ligeramente para centrar con el soporte */
  z-index: 2;
  touch-action: none;
  display: block;
}

/* === Botones === */
.boton-girar {
  position: absolute; top: 20px; left: 20px;
  width: 90px; height: 90px;
  background-color: #e74c3c; color: #fff;
  border: none; border-radius: 50%;
  font-size: 1.1em; cursor: pointer;
  z-index: 10;
  display:flex; justify-content:center; align-items:center;
  animation: brilloParpadeo 1s infinite alternate;
}
@keyframes brilloParpadeo {
  0% { box-shadow: 0 0 10px #ff9999; }
  100% { box-shadow: 0 0 25px #ff0000; }
}

.boton-instrucciones {
  position: absolute; bottom: 10px; left: 10px;
  background-color:#28a745;
  border:none; color:#fff;
  font-size:1em; padding:10px 20px;
  border-radius:8px; cursor:pointer; z-index:10;
}
.boton-volver {
  position: absolute; bottom: 10px; right: 10px;
  background-color:#3498db;
  border:none; color:#fff;
  font-size:1em; padding:10px 20px;
  border-radius:8px; cursor:pointer; z-index:10;
}

/* === Modal instrucciones === */
.modal {
  display:none; position:fixed; z-index:100; inset:0;
  background:rgba(0,0,0,0.8);
  justify-content:center; align-items:center;
}
.modal img {
  max-width:90%;
  max-height:90%;
  border-radius:10px;
}
.cerrar {
  position:absolute; top:20px; right:40px;
  font-size:2em; color:#fff;
  cursor:pointer; font-weight:bold;
}

/* === Escala responsiva adicional === */
@media (max-width: 600px) {
  #contenedor-ruleta {
    width: 95vw;
    max-width: none;
    aspect-ratio: 1/1.22;
  }
  #soporte-atras, #soporte-adelante {
    top: -3%;
    left: -3%;
    width: 106%;
    height: 106%;
  }
  #ruleta {
    width: 85%;
    top: 7%; /* también bajada proporcionalmente en móvil */
  }
  .boton-girar {
    width: 70px; height: 70px; font-size: 0.9em;
  }
}
</style>
</head>
<body>

<!-- === Contenedor principal con soportes === -->
<div id="contenedor-ruleta">
  <img id="soporte-atras" src="soporte_atras.png" alt="Soporte trasero">
  <canvas id="ruleta"></canvas>
  <img id="soporte-adelante" src="soporte_adelante.png" alt="Soporte delantero">
</div>

<!-- Botones -->
<button class="boton-girar" id="btnGirar">Girar</button>
<button class="boton-instrucciones" id="btnInstrucciones">Instrucciones</button>
<button class="boton-volver" id="btnVolver">Inicio</button>

<!-- Modal -->
<div id="modal" class="modal">
  <span id="cerrar" class="cerrar">&times;</span>
  <img id="imagenAmpliada" src="Instrucciones.png" alt="Instrucciones ampliadas">
</div>

<script>
/* === Ruleta multicapa (sin cambios funcionales) === */
const canvas = document.getElementById("ruleta");
const ctx = canvas.getContext("2d");
const contenedor = document.getElementById("contenedor-ruleta");

const capas = [
  { src: "ruleta_externa.png", rotation: 0, img:null, buf:null, bctx:null },
  { src: "ruleta_media.png",   rotation: 0, img:null, buf:null, bctx:null },
  { src: "ruleta_interna.png", rotation: 0, img:null, buf:null, bctx:null }
];

const DPR = Math.max(1, window.devicePixelRatio || 1);
let baseW = 0, baseH = 0;

let loaded = 0;
capas.forEach(c => {
  const im = new Image();
  im.src = c.src;
  im.onload = () => {
    c.img = im;
    loaded++;
    if (loaded === capas.length) init();
  };
});

function init(){
  resizeCanvas();
  capas.forEach(c => {
    const b = document.createElement("canvas");
    b.width = baseW; b.height = baseH;
    const bctx = b.getContext("2d");
    bctx.drawImage(c.img, 0, 0, baseW, baseH);
    c.buf = b; c.bctx = bctx;
  });
  drawAll();
}

function resizeCanvas() {
  const size = contenedor.clientWidth * 0.82;
  baseW = baseH = size;
  canvas.width  = size * DPR;
  canvas.height = size * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}

window.addEventListener("resize", () => {
  resizeCanvas();
  drawAll();
});

function drawAll(){
  ctx.clearRect(0, 0, baseW, baseH);
  for (const c of capas) {
    ctx.save();
    ctx.translate(baseW/2, baseH/2);
    ctx.rotate(c.rotation);
    ctx.drawImage(c.img, -baseW/2, -baseH/2, baseW, baseH);
    ctx.restore();
  }
}

function pickLayer(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const scale = baseW / rect.width;
  const x = (clientX - rect.left) * scale;
  const y = (clientY - rect.top)  * scale;
  const order = [2,1,0];
  for (const idx of order){
    const L = capas[idx];
    const cx = baseW/2, cy = baseH/2;
    const dx = x - cx, dy = y - cy;
    const cos = Math.cos(-L.rotation), sin = Math.sin(-L.rotation);
    const lx = cos*dx - sin*dy + cx;
    const ly = sin*dx + cos*dy + cy;
    if (lx<0||ly<0||lx>=baseW||ly>=baseH) continue;
    const a = L.bctx.getImageData(lx|0, ly|0, 1, 1).data[3];
    if (a > 5) return L;
  }
  return null;
}

let activeLayer = null, startAngle = 0, startRotation = 0;

canvas.addEventListener("pointerdown", e => {
  activeLayer = pickLayer(e.clientX, e.clientY);
  if (!activeLayer) return;
  canvas.setPointerCapture(e.pointerId);
  const rect = canvas.getBoundingClientRect();
  const scale = baseW / rect.width;
  const x = (e.clientX - rect.left) * scale - baseW/2;
  const y = (e.clientY - rect.top)  * scale - baseH/2;
  startAngle = Math.atan2(y, x);
  startRotation = activeLayer.rotation;
});

canvas.addEventListener("pointermove", e => {
  if (!activeLayer) return;
  const rect = canvas.getBoundingClientRect();
  const scale = baseW / rect.width;
  const x = (e.clientX - rect.left) * scale - baseW/2;
  const y = (e.clientY - rect.top)  * scale - baseH/2;
  const ang = Math.atan2(y, x);
  activeLayer.rotation = startRotation + (ang - startAngle);
  drawAll();
});
canvas.addEventListener("pointerup",   () => activeLayer = null);
canvas.addEventListener("pointerleave",() => activeLayer = null);

/* === Botones === */
const btnInstrucciones = document.getElementById('btnInstrucciones');
const modal = document.getElementById('modal');
btnInstrucciones.addEventListener('click', () => modal.style.display = 'flex');
document.getElementById('cerrar').onclick = () => modal.style.display = 'none';
window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
document.getElementById("btnVolver").addEventListener("click", () => { window.location.href = "index.html"; });

/* === Botón Girar === */
document.getElementById("btnGirar").addEventListener("click", () => {
  const start = performance.now();
  const configs = [
    { capa: capas[0], sentido: 1,  dur: 2000 + Math.random() * 1000, vueltas: 2 + Math.random() * 2 },
    { capa: capas[1], sentido: -1, dur: 2500 + Math.random() * 1000, vueltas: 2 + Math.random() * 2 },
    { capa: capas[2], sentido: 1,  dur: 3000 + Math.random() * 1000, vueltas: 2 + Math.random() * 2 }
  ];
  const inicios = capas.map(c => c.rotation);
  const ease = t => 1 - Math.pow(1 - t, 3);
  function animar(now) {
    let activo = false;
    configs.forEach((cfg, i) => {
      const t = Math.min(1, (now - start) / cfg.dur);
      const delta = ease(t) * (Math.PI * 2 * cfg.vueltas * cfg.sentido);
      cfg.capa.rotation = inicios[i] + delta;
      if (t < 1) activo = true;
    });
    drawAll();
    if (activo) requestAnimationFrame(animar);
  }
  requestAnimationFrame(animar);
});
</script>
</body>
</html>

